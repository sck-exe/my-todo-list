<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lista de Tareas Cifrada</title>
  <!-- Incluir CryptoJS desde CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js" integrity="sha512-a+SUDuwNzXDvz4XrIcXHuCf089/iJAoN4lmrXJg18XnduKK6YlDHNRalv4yd1N40OKI80tFidF+rqTFKGPoWFQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <style>
    :root {
      --bg-color: #000000;
      --text-color: #39FF14; /* Verde neón */
      --priority-color: #FF4136; /* Rojo */
      --button-bg: var(--text-color);
      --button-text: var(--bg-color);
      --input-bg: ivory;
      --input-text: #000000;
      --modal-bg: #1a1a1a; /* Fondo ligeramente más claro para modales */
      --border-color: #444;
      --delete-color: #ff4d4d; /* Rojo claro para eliminar */
      --delete-hover-color: #cc0000; /* Rojo oscuro hover */
      --restore-color: var(--text-color); /* Verde neón para restaurar */
    }
    body {
      font-family: 'Courier New', Courier, monospace;
      margin: 0;
      padding: 20px;
      background-color: var(--bg-color);
      background-image: url("https://www.transparenttextures.com/patterns/stardust.png");
      transition: background-color 0.3s ease, color 0.3s ease;
      min-height: 100vh;
      position: relative;
      color: var(--text-color);
    }
    input, button, select, textarea {
      font-family: inherit;
      color: var(--text-color); /* Color por defecto */
      border-radius: 3px;
      border: 1px solid var(--border-color);
    }
    label {
      color: var(--text-color);
    }
    .container {
      max-width: 600px;
      margin: 20px auto;
      padding: 20px;
    }
    .add-task-form {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    .add-task-form input[type="text"]{
      flex-grow: 1;
      background-color: var(--input-bg);
      color: var(--input-text) !important; /* Forzar color */
      padding: 10px;
      font-size: 1em;
    }
    .add-task-form input[type="date"] {
      padding: 10px;
      font-size: 1em;
      background-color: var(--input-bg) !important; /* Sobrescribir */
      color: var(--input-text) !important; /* Forzar color */
      min-width: 130px; /* Asegurar espacio para el selector de fecha */
    }
    .add-task-form button,
    .action-button { /* Estilo común para botones de acción */
      padding: 10px 15px;
      background-color: var(--button-bg);
      color: var(--button-text);
      border: none;
      cursor: pointer;
      font-size: 1em;
      transition: opacity 0.2s ease;
      white-space: nowrap; /* Evitar que el texto del botón se parta */
    }
    .add-task-form button:hover,
    .action-button:hover {
      opacity: 0.8;
    }
    #taskList, #deletedTaskList {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #taskList li, #deletedTaskList li {
      background-color: transparent;
      padding: 10px 15px; /* Reducido ligeramente */
      margin-bottom: 10px;
      border-radius: 3px;
      border: 1px solid var(--border-color); /* Borde sutil */
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: background-color 0.3s ease;
      word-break: break-word;
      color: var(--text-color); /* Asegurar color de texto */
      gap: 10px; /* Espacio entre contenido y acciones */
    }
    #taskList li.completed {
      opacity: 0.6;
      text-decoration: line-through;
    }
     #taskList li.completed .task-content span {
        text-decoration: line-through; /* Asegurar tachado del texto */
     }

    /* Contenido de la tarea (checkbox, icono, texto, fecha) */
    .task-content { /* Aplica a ambas listas */
      display: flex;
      align-items: center;
      gap: 8px; /* Espacio reducido */
      flex-grow: 1;
      margin-right: 10px; /* Espacio antes de los botones de acción */
      overflow: hidden; /* Evitar que el texto largo desborde */
    }
     .task-content span { /* Texto de la tarea */
        flex-shrink: 1; /* Permitir que el texto se encoja */
        min-width: 0; /* Necesario para que text-overflow funcione */
        white-space: nowrap; /* Evitar saltos de línea */
        overflow: hidden;
        text-overflow: ellipsis; /* Añadir puntos suspensivos si es muy largo */
     }

    #taskList li input[type="checkbox"] {
      cursor: pointer;
      transform: scale(1.2);
      margin-right: 5px;
      /* Estilo del checkbox para que contraste */
      accent-color: var(--text-color);
      flex-shrink: 0; /* Evitar que el checkbox se encoja */
    }
    .priority-icon { /* Aplica a ambas listas */
      color: var(--priority-color);
      font-weight: bold;
      font-size: 1.2em;
      display: none; /* Oculto por defecto */
      flex-shrink: 0; /* Evitar que el icono se encoja */
    }
     li.is-priority .priority-icon {
        display: inline; /* Mostrar si es prioritario */
    }
    .due-date { /* Aplica a ambas listas */
      font-size: 0.8em;
      margin-left: 10px; /* Espacio reducido */
      opacity: 0.8;
      white-space: nowrap;
      flex-shrink: 0; /* Evitar que la fecha se encoja */
    }
    .deleted-info { /* Específico para papelera */
        font-size: 0.75em;
        opacity: 0.6;
        margin-left: 10px;
        white-space: nowrap;
        flex-shrink: 0;
    }

     /* Contenedor de botones de acción */
    .task-actions {
        display: flex;
        align-items: center;
        gap: 8px; /* Espacio entre botones */
        flex-shrink: 0; /* Evitar que los botones se encojan */
    }

     /* Botones dentro de las listas */
    .task-actions button {
      background-color: transparent;
      border: none;
      cursor: pointer;
      font-size: 1.2em; /* Tamaño base */
      padding: 0 4px; /* Espacio reducido */
      transition: color 0.2s, transform 0.2s;
      line-height: 1; /* Ajustar altura */
    }
    .task-actions button:hover {
        transform: scale(1.15); /* Aumentar tamaño al pasar el ratón */
    }
    .priority-btn {
      color: #cccccc; /* Gris claro para no prioritario */
      font-weight: bold;
      font-size: 1.3em; /* Ligeramente más grande */
    }
    .priority-btn.active {
      color: var(--priority-color); /* Rojo si es prioritario */
    }
    .delete-btn {
      color: var(--delete-color);
      font-weight: bold;
    }
    .delete-btn:hover {
      color: var(--delete-hover-color);
    }
    .restore-btn {
        color: var(--restore-color);
        font-size: 1.4em; /* Icono un poco más grande */
    }
    .restore-btn:hover {
        color: white; /* Blanco al pasar el ratón */
    }
    .perm-delete-btn {
        color: var(--delete-color);
        font-size: 1.2em;
    }
     .perm-delete-btn:hover {
        color: var(--delete-hover-color);
     }

    #customImageContainer {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 150px;
      height: 150px;
      border: 2px solid var(--text-color);
      border-radius: 5px;
      overflow: hidden;
      background-color: rgba(255, 255, 255, 0.1); /* Más sutil */
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }
    #customImage {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #imageUpload {
      display: none;
    }

    /* Modales (Contraseña y Papelera) */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.85); /* Más oscuro */
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      display: none; /* Oculto por defecto */
      padding: 20px;
      box-sizing: border-box;
    }
    .modal-content {
      background-color: var(--modal-bg);
      color: var(--text-color);
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
      text-align: center;
      min-width: 300px;
      width: 90%; /* Ancho relativo */
      max-width: 700px; /* Ancho máximo */
      max-height: 90vh;
      display: flex; /* Usar flexbox para la estructura interna */
      flex-direction: column; /* Apilar elementos verticalmente */
      position: relative; /* Para el botón de cierre */
    }
     .modal-content h2 {
      margin-top: 0;
      margin-bottom: 20px;
      font-weight: normal;
      flex-shrink: 0; /* Evitar que el título se encoja */
    }
    /* Contenedor de la lista dentro del modal de papelera */
     .modal-list-container {
        overflow-y: auto; /* Hacer la lista desplazable */
        margin-bottom: 20px; /* Espacio antes de botones inferiores si los hubiera */
        flex-grow: 1; /* Permitir que ocupe el espacio disponible */
        border-top: 1px solid var(--border-color); /* Separador superior */
        border-bottom: 1px solid var(--border-color); /* Separador inferior */
        padding: 15px 0; /* Espacio interno */
     }
     #deletedTaskList {
        padding: 0 10px; /* Padding lateral dentro del scroll */
     }

    .modal-content label {
      display: block;
      margin-bottom: 8px;
      font-size: 0.9em;
    }
    .modal-content input[type="password"] { /* Solo para modal contraseña */
      width: 80%;
      padding: 10px;
      margin-bottom: 20px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 1em;
      background-color: var(--input-bg);
      color: var(--input-text);
    }
    /* Botones del Modal (Submit Contraseña, Cerrar) */
    .modal-content button[type="submit"], /* Solo para modal contraseña */
    .modal-close-btn {
      padding: 10px 20px;
      font-size: 1em;
      cursor: pointer;
      background-color: var(--button-bg);
      color: var(--button-text);
      border: none;
      border-radius: 4px;
      transition: opacity 0.2s;
      margin-top: 10px; /* Espacio arriba */
      flex-shrink: 0; /* Evitar que se encojan */
    }
    .modal-content button[type="submit"]:hover,
    .modal-close-btn:hover {
      opacity: 0.8;
    }
    .modal-close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        background: transparent;
        color: var(--text-color);
        font-size: 1.8em; /* Más grande */
        padding: 0px 8px; /* Ajuste padding */
        line-height: 1;
        border: none; /* Quitar borde */
    }
     .modal-close-btn:hover {
        color: var(--priority-color);
        opacity: 1;
        transform: scale(1.1); /* Efecto hover */
     }
    #passwordError {
      color: var(--priority-color); /* Rojo para errores */
      margin-top: 15px;
      font-size: 0.9em;
      min-height: 1.2em;
      flex-shrink: 0; /* Evitar que se encoja */
    }
    #emptyTrashMessage {
        font-style: italic;
        opacity: 0.7;
        padding: 20px;
    }
    /* Ocultar contenido principal inicialmente */
    .content-hidden {
      visibility: hidden;
      opacity: 0;
      transition: visibility 0s 0.3s, opacity 0.3s ease; /* Transición suave */
    }
    /* Estilos para el div de imagen del título */
    #titleImage {
      text-align: center;
      margin-bottom: 30px;
    }
    #titleImage img {
      max-width: 100%;
      height: auto;
    }

    /* Botón de Papelera */
    #trashActions {
        margin-bottom: 20px;
        text-align: right; /* Alinear botón a la derecha */
    }
     #showTrashBtn {
        /* Usa el estilo .action-button definido antes */
        font-size: 0.9em;
     }
     #trashCount {
        font-weight: bold;
        margin-left: 3px;
     }
  </style>
</head>
<body>
  <!-- Modal de Contraseña -->
  <div id="passwordOverlay" class="modal-overlay">
    <div class="modal-content">
      <h2 id="passwordTitle">Introduce la contraseña</h2>
      <form id="passwordForm">
        <label for="passwordInput">Contraseña:</label>
        <input type="password" id="passwordInput" required />
        <div id="passwordError"></div>
        <button type="submit" id="passwordSubmit">Desbloquear</button>
      </form>
    </div>
  </div>

  <!-- Modal de Papelera -->
   <div id="trashOverlay" class="modal-overlay">
    <div class="modal-content">
      <button class="modal-close-btn" id="closeTrashBtn" title="Cerrar Papelera">×</button>
      <h2>Papelera</h2>
      <div class="modal-list-container">
          <ul id="deletedTaskList">
            <!-- Las tareas eliminadas se añadirán aquí -->
          </ul>
          <p id="emptyTrashMessage" style="display: none;">La papelera está vacía.</p>
      </div>
    </div>
  </div>

  <!-- Contenido Principal (inicialmente oculto) -->
  <div class="container content-hidden" id="mainContent">
    <!-- Div de imagen en lugar del título -->
    <div id="titleImage">
      <img src="title.png" alt="Título" width="200px" height="auto" />
    </div>

    <form class="add-task-form" id="addTaskForm" autocomplete="off">
      <input type="text" id="taskInput" placeholder="Nueva tarea..." required />
      <input type="date" id="dueDateInput" title="Fecha límite (opcional)" />
      <button type="submit">Añadir</button>
    </form>

    <!-- Botón para abrir la papelera -->
    <div id="trashActions">
        <button id="showTrashBtn" class="action-button">Papelera <span id="trashCount">(0)</span></button>
    </div>

    <ul id="taskList">
      <!-- Las tareas se añadirán aquí con JavaScript -->
    </ul>
  </div>

  <div id="customImageContainer" class="content-hidden">
    <img id="customImage" src="image.png" alt="Imagen personalizable" />
  </div>

  <script>
    // --- Constantes de Cifrado ---
    const SALT_KEY = 'tasksSalt';
    const ENCRYPTED_DATA_KEY = 'encryptedAppData'; // Clave para todo el estado
    const PBKDF2_ITERATIONS = 10000;
    const KEY_SIZE_BITS = 256;

    // Variable global para la clave derivada (en memoria)
    let sessionKey = null;
    // Arrays para tareas activas y borradas
    let tasksData = [];
    let deletedTasks = [];

    document.addEventListener('DOMContentLoaded', () => {
      // --- Referencias a elementos del DOM ---
      const taskInput = document.getElementById('taskInput');
      const dueDateInput = document.getElementById('dueDateInput');
      const addTaskForm = document.getElementById('addTaskForm');
      const taskList = document.getElementById('taskList');
      const imageUpload = document.getElementById('imageUpload'); // Aunque no se usa, lo dejamos por si acaso
      const customImage = document.getElementById('customImage');
      const customImageContainer = document.getElementById('customImageContainer');
      const mainContent = document.getElementById('mainContent');

      // Modal de contraseña
      const passwordOverlay = document.getElementById('passwordOverlay');
      const passwordForm = document.getElementById('passwordForm');
      const passwordInput = document.getElementById('passwordInput');
      const passwordError = document.getElementById('passwordError');
      const passwordTitle = document.getElementById('passwordTitle');
      const passwordSubmit = document.getElementById('passwordSubmit');

      // Papelera
      const trashOverlay = document.getElementById('trashOverlay');
      const showTrashBtn = document.getElementById('showTrashBtn');
      const closeTrashBtn = document.getElementById('closeTrashBtn');
      const deletedTaskList = document.getElementById('deletedTaskList');
      const trashCountSpan = document.getElementById('trashCount');
      const emptyTrashMessage = document.getElementById('emptyTrashMessage');

      // --- Inicialización ---
      initApp();

      function initApp() {
        const storedSalt = localStorage.getItem(SALT_KEY);
        const encryptedData = localStorage.getItem(ENCRYPTED_DATA_KEY);

        passwordOverlay.style.display = 'flex'; // Mostrar modal de contraseña

        if (storedSalt && encryptedData) {
          passwordTitle.textContent = 'Introduce la contraseña';
          passwordSubmit.textContent = 'Desbloquear';
        } else {
          passwordTitle.textContent = 'Crea una contraseña para cifrar tus tareas';
          passwordSubmit.textContent = 'Guardar y Empezar';
          if (!storedSalt) {
            const newSalt = CryptoJS.lib.WordArray.random(128 / 8).toString(CryptoJS.enc.Hex);
            localStorage.setItem(SALT_KEY, newSalt);
            console.log("Nueva sal generada.");
          }
          if (!encryptedData) {
            localStorage.removeItem(ENCRYPTED_DATA_KEY); // Limpiar por si acaso
            tasksData = [];
            deletedTasks = [];
            console.log("No hay datos cifrados, inicializando.");
          }
        }
        passwordForm.onsubmit = handlePasswordSubmit;
      }

      function handlePasswordSubmit(e) {
        e.preventDefault();
        const password = passwordInput.value;
        const salt = localStorage.getItem(SALT_KEY);
        passwordError.textContent = ''; // Limpiar errores previos

        if (!password) {
          passwordError.textContent = 'La contraseña no puede estar vacía.';
          return;
        }
        if (!salt) {
          passwordError.textContent = 'Error crítico: Falta la sal de cifrado.';
          console.error("Error crítico: Falta la sal de cifrado.");
          return;
        }

        console.log("Derivando clave...");
        sessionKey = deriveKey(password, salt);
        console.log("Clave derivada (oculta en producción).");

        const encryptedData = localStorage.getItem(ENCRYPTED_DATA_KEY);

        if (encryptedData) {
          console.log("Intentando descifrar datos existentes...");
          const decryptedJson = decryptData(encryptedData, sessionKey);
          if (decryptedJson !== null) {
            try {
              const appData = JSON.parse(decryptedJson);
              // Validar estructura básica
              tasksData = Array.isArray(appData.tasks) ? appData.tasks : [];
              deletedTasks = Array.isArray(appData.deleted) ? appData.deleted : [];
              console.log(`Datos descifrados: ${tasksData.length} tareas, ${deletedTasks.length} en papelera.`);
              unlockApp();
            } catch (error) {
              console.error("Error al parsear JSON descifrado:", error);
              passwordError.textContent = 'Contraseña incorrecta o datos corruptos.';
              sessionKey = null; // Resetear clave
              passwordInput.value = ''; // Limpiar campo
            }
          } else {
            console.warn("Descifrado fallido (probablemente contraseña incorrecta).");
            passwordError.textContent = 'Contraseña incorrecta o datos corruptos.';
            sessionKey = null; // Resetear clave
            passwordInput.value = ''; // Limpiar campo
          }
        } else {
          // Primera vez o datos borrados
          console.log("No hay datos cifrados, empezando con listas vacías.");
          tasksData = [];
          deletedTasks = [];
          unlockApp();
          saveAppData(); // Guardar el estado inicial (vacío pero cifrado)
        }
      }

      function unlockApp() {
        passwordOverlay.style.display = 'none';
        passwordInput.value = ''; // Limpiar campo de contraseña por seguridad
        mainContent.classList.remove('content-hidden'); // Mostrar contenido
        customImageContainer.classList.remove('content-hidden'); // Mostrar imagen

        renderTasks(); // Dibujar tareas activas
        updateTrashCount(); // Actualizar contador de papelera

        // Añadir listeners de eventos (asegurarse de no duplicarlos)
        addTaskForm.removeEventListener('submit', handleAddTask);
        addTaskForm.addEventListener('submit', handleAddTask);

        taskList.removeEventListener('click', handleTaskListClick);
        taskList.addEventListener('click', handleTaskListClick);

        showTrashBtn.removeEventListener('click', openTrashModal);
        showTrashBtn.addEventListener('click', openTrashModal);

        closeTrashBtn.removeEventListener('click', closeTrashModal);
        closeTrashBtn.addEventListener('click', closeTrashModal);

        deletedTaskList.removeEventListener('click', handleTrashListClick);
        deletedTaskList.addEventListener('click', handleTrashListClick);

        console.log("Aplicación desbloqueada y listeners añadidos.");
      }

      function handleAddTask(e) {
        e.preventDefault();
        const taskText = taskInput.value.trim();
        const dueDate = dueDateInput.value;
        if (!taskText) return; // No añadir tareas vacías

        const newTask = {
          text: taskText,
          dueDate: dueDate || '',
          completed: false,
          isPriority: false, // Por defecto no es prioritaria
          id: Date.now() // ID único basado en timestamp
        };

        tasksData.push(newTask);

        renderTasks(); // Re-renderizar lista principal (para ordenación)
        saveAppData(); // Guardar cambios
        taskInput.value = ''; // Limpiar input de texto
        dueDateInput.value = ''; // Limpiar input de fecha
        taskInput.focus(); // Poner el foco de nuevo en el input de texto
      }

      // --- Manejador de Clicks en la Lista Principal ---
      function handleTaskListClick(e) {
        const target = e.target;
        const li = target.closest('li'); // Encontrar el <li> padre
        if (!li) return; // Salir si el click no fue dentro de un <li>

        const taskId = parseInt(li.dataset.taskId, 10);
        const taskIndex = tasksData.findIndex(task => task.id === taskId);
        if (taskIndex === -1) {
            console.warn(`Tarea con ID ${taskId} no encontrada en tasksData.`);
            return; // Tarea no encontrada (raro, pero posible)
        }

        // Click en Checkbox (Completar/Descompletar)
        if (target.type === 'checkbox') {
          tasksData[taskIndex].completed = target.checked;
          li.classList.toggle('completed', target.checked); // Actualizar clase CSS
          // Actualizar el tachado explícitamente si es necesario
          const textSpan = li.querySelector('.task-content span');
          if (textSpan) {
            textSpan.style.textDecoration = target.checked ? 'line-through' : 'none';
          }
          saveAppData(); // Guardar el cambio
        }
        // Click en Botón de Prioridad
        else if (target.classList.contains('priority-btn')) {
          tasksData[taskIndex].isPriority = !tasksData[taskIndex].isPriority;
          // Re-renderizar toda la lista para mantener el orden por prioridad
          renderTasks();
          saveAppData();
        }
        // Click en Botón de Eliminar (Mover a Papelera)
        else if (target.classList.contains('delete-btn')) {
          // Eliminar la confirmación por ahora para simplificar
          const taskToMove = tasksData.splice(taskIndex, 1)[0]; // Quitar de tasksData
          if (taskToMove) {
            taskToMove.deletedAt = Date.now(); // Añadir timestamp de borrado
            deletedTasks.push(taskToMove); // Añadir a deletedTasks

            li.remove(); // Quitar del DOM visualmente
            updateTrashCount(); // Actualizar contador
            saveAppData(); // Guardar cambios
            console.log(`Tarea ${taskId} movida a la papelera.`);
          } else {
            console.error(`No se pudo encontrar la tarea ${taskId} para eliminar.`);
          }
        }
      }

      // --- Manejador de Clicks en la Papelera ---
      function handleTrashListClick(e) {
         const target = e.target;
         const li = target.closest('li');
         if (!li) return;

         const taskId = parseInt(li.dataset.taskId, 10);
         const taskIndex = deletedTasks.findIndex(task => task.id === taskId);
         if (taskIndex === -1) {
             console.warn(`Tarea con ID ${taskId} no encontrada en deletedTasks.`);
             return; // Tarea no encontrada en la papelera
         }

         // Click en Restaurar
         if (target.classList.contains('restore-btn')) {
            const taskToRestore = deletedTasks.splice(taskIndex, 1)[0]; // Quitar de la papelera
            if (taskToRestore) {
                delete taskToRestore.deletedAt; // Quitar timestamp de borrado
                tasksData.push(taskToRestore); // Añadir de nuevo a tareas activas

                renderTasks(); // Re-renderizar lista principal
                renderTrash(); // Re-renderizar papelera (ahora tiene un item menos)
                updateTrashCount(); // Actualizar contador
                saveAppData(); // Guardar cambios
                console.log(`Tarea ${taskId} restaurada.`);
            }
         }
         // Click en Borrar Permanentemente
         else if (target.classList.contains('perm-delete-btn')) {
            // Añadir confirmación para borrado permanente
            if (confirm(`¿Seguro que quieres eliminar permanentemente la tarea "${deletedTasks[taskIndex].text}"? Esta acción no se puede deshacer.`)) {
                deletedTasks.splice(taskIndex, 1); // Eliminar definitivamente

                li.remove(); // Quitar del DOM de la papelera
                updateTrashCount(); // Actualizar contador
                saveAppData(); // Guardar cambios
                checkEmptyTrash(); // Verificar si la papelera quedó vacía y mostrar mensaje
                console.log(`Tarea ${taskId} eliminada permanentemente.`);
            }
         }
      }

      // --- Funciones de Cifrado ---
      function deriveKey(password, salt) {
        const saltWA = (typeof salt === 'string') ? CryptoJS.enc.Hex.parse(salt) : salt;
        return CryptoJS.PBKDF2(password, saltWA, {
          keySize: KEY_SIZE_BITS / 32,
          iterations: PBKDF2_ITERATIONS,
          hasher: CryptoJS.algo.SHA256
        });
      }

      function encryptData(plaintext, key) {
        if (!key) { console.error("Error de cifrado: Falta la clave."); return null; }
        try {
          const iv = CryptoJS.lib.WordArray.random(128 / 8);
          const encrypted = CryptoJS.AES.encrypt(plaintext, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
          const ivBase64 = CryptoJS.enc.Base64.stringify(iv);
          return ivBase64 + ':' + encrypted.toString();
        } catch (error) { console.error("Error durante el cifrado:", error); return null; }
      }

      function decryptData(ciphertextWithIv, key) {
        if (!key) { console.error("Error de descifrado: Falta la clave."); return null; }
        try {
          const parts = ciphertextWithIv.split(':');
          if (parts.length !== 2) { console.error("Error de descifrado: Formato inválido (falta separador IV)."); return null; }
          const iv = CryptoJS.enc.Base64.parse(parts[0]);
          const ciphertext = parts[1];
          const decrypted = CryptoJS.AES.decrypt(ciphertext, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
          const plaintext = decrypted.toString(CryptoJS.enc.Utf8);
          if (!plaintext && ciphertext.length > 0) { console.warn("Descifrado resultó en cadena vacía, posible error."); return null; }
          return plaintext;
        } catch (error) { console.error("Error durante el descifrado:", error); return null; }
      }

      // --- Persistencia (Guardar Estado Completo) ---
      function saveAppData() {
        if (!sessionKey) {
            console.warn("Intento de guardar sin clave de sesión.");
            alert("Error de seguridad: No se puede guardar. Intenta recargar.");
            return; // No guardar si no hay clave
        }
        const appData = {
            tasks: tasksData,
            deleted: deletedTasks
        };
        const appDataJson = JSON.stringify(appData);
        const encryptedData = encryptData(appDataJson, sessionKey);

        if (encryptedData) {
          localStorage.setItem(ENCRYPTED_DATA_KEY, encryptedData);
          // console.log("Datos de aplicación guardados cifrados."); // Log de depuración
        } else {
          alert("Error crítico: No se pudieron guardar los cambios de forma segura.");
          console.error("Fallo al cifrar datos para guardar.");
        }
      }

      // --- Renderizado de Tareas Activas ---
      function renderTasks() {
        taskList.innerHTML = ''; // Limpiar lista actual
        if (!Array.isArray(tasksData)) tasksData = []; // Asegurar que sea un array

        // Ordenar: Prioritarias primero, luego incompletas, luego completas. Dentro de cada grupo, por ID (fecha creación)
        const sortedTasks = [...tasksData].sort((a, b) => {
            if (a.isPriority !== b.isPriority) return a.isPriority ? -1 : 1; // Prioritarias primero
            if (a.completed !== b.completed) return a.completed ? 1 : -1; // Incompletas antes que completas
            return a.id - b.id; // Mismo estado, ordenar por creación (más antiguas primero)
        });

        sortedTasks.forEach(task => renderSingleTask(task));
        console.log("Lista de tareas renderizada.");
      }

      function renderSingleTask(task, existingLi = null) {
         const li = existingLi || document.createElement('li');
         if (!existingLi) li.dataset.taskId = task.id; // Añadir dataset solo si es nuevo
         li.innerHTML = ''; // Limpiar contenido previo
         li.className = ''; // Limpiar clases previas
         if (task.completed) li.classList.add('completed');
         if (task.isPriority) li.classList.add('is-priority');

         // Contenedor principal para contenido y acciones
         li.style.display = 'flex';
         li.style.alignItems = 'center';
         li.style.justifyContent = 'space-between';

         // --- Task Content (Checkbox, Icono Prioridad, Texto, Fecha) ---
         const taskContent = document.createElement('div');
         taskContent.classList.add('task-content');

         const checkbox = document.createElement('input');
         checkbox.type = 'checkbox';
         checkbox.checked = task.completed;
         checkbox.title = task.completed ? "Marcar como pendiente" : "Marcar como completada";
         taskContent.appendChild(checkbox);

         const priorityIcon = document.createElement('span');
         priorityIcon.classList.add('priority-icon');
         priorityIcon.innerHTML = '❗';
         priorityIcon.title = "Tarea prioritaria";
         taskContent.appendChild(priorityIcon); // CSS se encarga de mostrar/ocultar

         const textSpan = document.createElement('span');
         textSpan.textContent = task.text;
         textSpan.title = task.text; // Tooltip con texto completo
         if (task.completed) { // Aplicar tachado directamente aquí también
            textSpan.style.textDecoration = 'line-through';
         }
         taskContent.appendChild(textSpan);

         if (task.dueDate) {
           const dateSpan = document.createElement('span');
           dateSpan.classList.add('due-date');
           dateSpan.textContent = `(${formatDate(task.dueDate)})`;
           taskContent.appendChild(dateSpan);
         }
         li.appendChild(taskContent);

         // --- Task Actions (Botones) ---
         const taskActions = document.createElement('div');
         taskActions.classList.add('task-actions');

         const priorityBtn = document.createElement('button');
         priorityBtn.classList.add('priority-btn');
         priorityBtn.classList.toggle('active', task.isPriority);
         priorityBtn.innerHTML = '!'; // Usar texto simple por ahora
         priorityBtn.title = task.isPriority ? "Quitar prioridad" : "Marcar como prioritaria";
         taskActions.appendChild(priorityBtn);

         const deleteBtn = document.createElement('button');
         deleteBtn.classList.add('delete-btn');
         deleteBtn.innerHTML = '×'; // Icono simple de eliminar
         deleteBtn.title = 'Mover a la papelera';
         taskActions.appendChild(deleteBtn);

         li.appendChild(taskActions);

         // Añadir a la lista si es un elemento nuevo
         if (!existingLi) {
             taskList.appendChild(li);
         }
      }

      // --- Funciones de la Papelera ---
      function openTrashModal() {
          renderTrash(); // Asegurar contenido actualizado
          trashOverlay.style.display = 'flex'; // Mostrar modal
      }

      function closeTrashModal() {
          trashOverlay.style.display = 'none'; // Ocultar modal
      }

      function renderTrash() {
          deletedTaskList.innerHTML = ''; // Limpiar lista de papelera
          if (!Array.isArray(deletedTasks)) deletedTasks = []; // Asegurar array

          checkEmptyTrash(); // Mostrar/ocultar mensaje de vacío

          // Ordenar tareas borradas por fecha de borrado (más recientes primero)
          const sortedDeletedTasks = [...deletedTasks].sort((a, b) => (b.deletedAt || 0) - (a.deletedAt || 0));

          sortedDeletedTasks.forEach(task => {
            const li = document.createElement('li');
            li.dataset.taskId = task.id;
            // Aplicar clases para consistencia visual (aunque no funcionales aquí)
            if (task.completed) li.classList.add('completed');
            if (task.isPriority) li.classList.add('is-priority');
            li.style.opacity = 0.8; // Atenuar ligeramente las tareas borradas

            // --- Contenido de la tarea borrada ---
            const taskContent = document.createElement('div');
            taskContent.classList.add('task-content');

            // Icono de prioridad (si aplica)
            const priorityIcon = document.createElement('span');
            priorityIcon.classList.add('priority-icon');
            priorityIcon.innerHTML = '❗';
            taskContent.appendChild(priorityIcon);

            // Texto (tachado si estaba completada)
            const textSpan = document.createElement('span');
            textSpan.textContent = task.text;
            textSpan.title = task.text;
             if (task.completed) textSpan.style.textDecoration = 'line-through';
            taskContent.appendChild(textSpan);

            // Fecha límite (si aplica)
            if (task.dueDate) {
              const dateSpan = document.createElement('span');
              dateSpan.classList.add('due-date');
              dateSpan.textContent = `(${formatDate(task.dueDate)})`;
              taskContent.appendChild(dateSpan);
            }

            // Fecha de borrado
            if (task.deletedAt) {
                const deletedInfoSpan = document.createElement('span');
                deletedInfoSpan.classList.add('deleted-info');
                deletedInfoSpan.textContent = `[Borrado: ${formatDateTime(task.deletedAt)}]`;
                taskContent.appendChild(deletedInfoSpan);
            }

            li.appendChild(taskContent);

            // --- Acciones en la papelera ---
            const taskActions = document.createElement('div');
            taskActions.classList.add('task-actions');

            // Botón Restaurar
            const restoreBtn = document.createElement('button');
            restoreBtn.classList.add('restore-btn');
            restoreBtn.innerHTML = '↺'; // Icono de restaurar (flecha circular)
            restoreBtn.title = 'Restaurar tarea';
            taskActions.appendChild(restoreBtn);

            // Botón Borrar Permanentemente
            const permDeleteBtn = document.createElement('button');
            permDeleteBtn.classList.add('perm-delete-btn');
            permDeleteBtn.innerHTML = ''; // Icono de papelera
            // permDeleteBtn.innerHTML = '×'; // Alternativa simple
            permDeleteBtn.title = 'Eliminar permanentemente';
            taskActions.appendChild(permDeleteBtn);

            li.appendChild(taskActions);
            deletedTaskList.appendChild(li);
          });
          console.log("Papelera renderizada.");
      }

      function updateTrashCount() {
        const count = Array.isArray(deletedTasks) ? deletedTasks.length : 0;
        trashCountSpan.textContent = `(${count})`;
      }

      function checkEmptyTrash() {
          const isEmpty = !Array.isArray(deletedTasks) || deletedTasks.length === 0;
          emptyTrashMessage.style.display = isEmpty ? 'block' : 'none';
          deletedTaskList.style.display = isEmpty ? 'none' : 'block'; // Ocultar ul si está vacío
      }

      // --- Funciones de Utilidad ---
      function formatDate(dateString) {
        if (!dateString) return '';
        try {
          // Asumir que la fecha es YYYY-MM-DD
          const date = new Date(dateString + 'T00:00:00'); // Añadir hora para evitar problemas de zona horaria
          if (isNaN(date.getTime())) return dateString; // Devolver original si no es válida
          const day = String(date.getDate()).padStart(2, '0');
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const year = date.getFullYear();
          return `${day}/${month}/${year}`;
        } catch (e) {
          console.error("Error formateando fecha:", dateString, e);
          return dateString; // Devolver original en caso de error
        }
      }

      function formatDateTime(timestamp) {
          if (!timestamp) return '';
          try {
              const date = new Date(timestamp);
              return date.toLocaleString('es-ES', { // Formato local español
                  day: '2-digit',
                  month: '2-digit',
                  year: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit'
              });
          } catch(e) {
              console.error("Error formateando fecha/hora:", timestamp, e);
              return new Date(timestamp).toLocaleDateString(); // Fallback a solo fecha
          }
      }

    }); // Fin DOMContentLoaded
  </script>
</body>
</html>